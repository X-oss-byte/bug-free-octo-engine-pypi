// Code generated by capnpc-go. DO NOT EDIT.

package capnp

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	schemas "capnproto.org/go/capnp/v3/schemas"
)

type TaskHashable capnp.Struct

// TaskHashable_TypeID is the unique identifier for the type TaskHashable.
const TaskHashable_TypeID = 0xe1f09ceb4ef5e479

func NewTaskHashable(s *capnp.Segment) (TaskHashable, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 12})
	return TaskHashable(st), err
}

func NewRootTaskHashable(s *capnp.Segment) (TaskHashable, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 12})
	return TaskHashable(st), err
}

func ReadRootTaskHashable(msg *capnp.Message) (TaskHashable, error) {
	root, err := msg.Root()
	return TaskHashable(root.Struct()), err
}

func (s TaskHashable) String() string {
	str, _ := text.Marshal(0xe1f09ceb4ef5e479, capnp.Struct(s))
	return str
}

func (s TaskHashable) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (TaskHashable) DecodeFromPtr(p capnp.Ptr) TaskHashable {
	return TaskHashable(capnp.Struct{}.DecodeFromPtr(p))
}

func (s TaskHashable) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s TaskHashable) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s TaskHashable) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s TaskHashable) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s TaskHashable) GlobalHash() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s TaskHashable) HasGlobalHash() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s TaskHashable) GlobalHashBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s TaskHashable) SetGlobalHash(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s TaskHashable) TaskDependencyHashes() (capnp.TextList, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return capnp.TextList(p.List()), err
}

func (s TaskHashable) HasTaskDependencyHashes() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s TaskHashable) SetTaskDependencyHashes(v capnp.TextList) error {
	return capnp.Struct(s).SetPtr(1, v.ToPtr())
}

// NewTaskDependencyHashes sets the taskDependencyHashes field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s TaskHashable) NewTaskDependencyHashes(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = capnp.Struct(s).SetPtr(1, l.ToPtr())
	return l, err
}
func (s TaskHashable) PackageDir() (string, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return p.Text(), err
}

func (s TaskHashable) HasPackageDir() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s TaskHashable) PackageDirBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return p.TextBytes(), err
}

func (s TaskHashable) SetPackageDir(v string) error {
	return capnp.Struct(s).SetText(2, v)
}

func (s TaskHashable) HashOfFiles() (string, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return p.Text(), err
}

func (s TaskHashable) HasHashOfFiles() bool {
	return capnp.Struct(s).HasPtr(3)
}

func (s TaskHashable) HashOfFilesBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return p.TextBytes(), err
}

func (s TaskHashable) SetHashOfFiles(v string) error {
	return capnp.Struct(s).SetText(3, v)
}

func (s TaskHashable) ExternalDepsHash() (string, error) {
	p, err := capnp.Struct(s).Ptr(4)
	return p.Text(), err
}

func (s TaskHashable) HasExternalDepsHash() bool {
	return capnp.Struct(s).HasPtr(4)
}

func (s TaskHashable) ExternalDepsHashBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(4)
	return p.TextBytes(), err
}

func (s TaskHashable) SetExternalDepsHash(v string) error {
	return capnp.Struct(s).SetText(4, v)
}

func (s TaskHashable) Task() (string, error) {
	p, err := capnp.Struct(s).Ptr(5)
	return p.Text(), err
}

func (s TaskHashable) HasTask() bool {
	return capnp.Struct(s).HasPtr(5)
}

func (s TaskHashable) TaskBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(5)
	return p.TextBytes(), err
}

func (s TaskHashable) SetTask(v string) error {
	return capnp.Struct(s).SetText(5, v)
}

func (s TaskHashable) Outputs() (TaskOutputs, error) {
	p, err := capnp.Struct(s).Ptr(6)
	return TaskOutputs(p.Struct()), err
}

func (s TaskHashable) HasOutputs() bool {
	return capnp.Struct(s).HasPtr(6)
}

func (s TaskHashable) SetOutputs(v TaskOutputs) error {
	return capnp.Struct(s).SetPtr(6, capnp.Struct(v).ToPtr())
}

// NewOutputs sets the outputs field to a newly
// allocated TaskOutputs struct, preferring placement in s's segment.
func (s TaskHashable) NewOutputs() (TaskOutputs, error) {
	ss, err := NewTaskOutputs(capnp.Struct(s).Segment())
	if err != nil {
		return TaskOutputs{}, err
	}
	err = capnp.Struct(s).SetPtr(6, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s TaskHashable) PassThruArgs() (capnp.TextList, error) {
	p, err := capnp.Struct(s).Ptr(7)
	return capnp.TextList(p.List()), err
}

func (s TaskHashable) HasPassThruArgs() bool {
	return capnp.Struct(s).HasPtr(7)
}

func (s TaskHashable) SetPassThruArgs(v capnp.TextList) error {
	return capnp.Struct(s).SetPtr(7, v.ToPtr())
}

// NewPassThruArgs sets the passThruArgs field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s TaskHashable) NewPassThruArgs(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = capnp.Struct(s).SetPtr(7, l.ToPtr())
	return l, err
}
func (s TaskHashable) Env() (capnp.TextList, error) {
	p, err := capnp.Struct(s).Ptr(8)
	return capnp.TextList(p.List()), err
}

func (s TaskHashable) HasEnv() bool {
	return capnp.Struct(s).HasPtr(8)
}

func (s TaskHashable) SetEnv(v capnp.TextList) error {
	return capnp.Struct(s).SetPtr(8, v.ToPtr())
}

// NewEnv sets the env field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s TaskHashable) NewEnv(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = capnp.Struct(s).SetPtr(8, l.ToPtr())
	return l, err
}
func (s TaskHashable) ResolvedEnvVars() (capnp.TextList, error) {
	p, err := capnp.Struct(s).Ptr(9)
	return capnp.TextList(p.List()), err
}

func (s TaskHashable) HasResolvedEnvVars() bool {
	return capnp.Struct(s).HasPtr(9)
}

func (s TaskHashable) SetResolvedEnvVars(v capnp.TextList) error {
	return capnp.Struct(s).SetPtr(9, v.ToPtr())
}

// NewResolvedEnvVars sets the resolvedEnvVars field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s TaskHashable) NewResolvedEnvVars(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = capnp.Struct(s).SetPtr(9, l.ToPtr())
	return l, err
}
func (s TaskHashable) PassThruEnv() (capnp.TextList, error) {
	p, err := capnp.Struct(s).Ptr(10)
	return capnp.TextList(p.List()), err
}

func (s TaskHashable) HasPassThruEnv() bool {
	return capnp.Struct(s).HasPtr(10)
}

func (s TaskHashable) SetPassThruEnv(v capnp.TextList) error {
	return capnp.Struct(s).SetPtr(10, v.ToPtr())
}

// NewPassThruEnv sets the passThruEnv field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s TaskHashable) NewPassThruEnv(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = capnp.Struct(s).SetPtr(10, l.ToPtr())
	return l, err
}
func (s TaskHashable) EnvMode() TaskHashable_EnvMode {
	return TaskHashable_EnvMode(capnp.Struct(s).Uint16(0))
}

func (s TaskHashable) SetEnvMode(v TaskHashable_EnvMode) {
	capnp.Struct(s).SetUint16(0, uint16(v))
}

func (s TaskHashable) DotEnv() (capnp.TextList, error) {
	p, err := capnp.Struct(s).Ptr(11)
	return capnp.TextList(p.List()), err
}

func (s TaskHashable) HasDotEnv() bool {
	return capnp.Struct(s).HasPtr(11)
}

func (s TaskHashable) SetDotEnv(v capnp.TextList) error {
	return capnp.Struct(s).SetPtr(11, v.ToPtr())
}

// NewDotEnv sets the dotEnv field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s TaskHashable) NewDotEnv(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = capnp.Struct(s).SetPtr(11, l.ToPtr())
	return l, err
}

// TaskHashable_List is a list of TaskHashable.
type TaskHashable_List = capnp.StructList[TaskHashable]

// NewTaskHashable creates a new list of TaskHashable.
func NewTaskHashable_List(s *capnp.Segment, sz int32) (TaskHashable_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 12}, sz)
	return capnp.StructList[TaskHashable](l), err
}

// TaskHashable_Future is a wrapper for a TaskHashable promised by a client call.
type TaskHashable_Future struct{ *capnp.Future }

func (f TaskHashable_Future) Struct() (TaskHashable, error) {
	p, err := f.Future.Ptr()
	return TaskHashable(p.Struct()), err
}
func (p TaskHashable_Future) Outputs() TaskOutputs_Future {
	return TaskOutputs_Future{Future: p.Future.Field(6, nil)}
}

type TaskHashable_EnvMode uint16

// TaskHashable_EnvMode_TypeID is the unique identifier for the type TaskHashable_EnvMode.
const TaskHashable_EnvMode_TypeID = 0x8dc08a1d29f69b16

// Values of TaskHashable_EnvMode.
const (
	TaskHashable_EnvMode_infer  TaskHashable_EnvMode = 0
	TaskHashable_EnvMode_loose  TaskHashable_EnvMode = 1
	TaskHashable_EnvMode_strict TaskHashable_EnvMode = 2
)

// String returns the enum's constant name.
func (c TaskHashable_EnvMode) String() string {
	switch c {
	case TaskHashable_EnvMode_infer:
		return "infer"
	case TaskHashable_EnvMode_loose:
		return "loose"
	case TaskHashable_EnvMode_strict:
		return "strict"

	default:
		return ""
	}
}

// TaskHashable_EnvModeFromString returns the enum value with a name,
// or the zero value if there's no such value.
func TaskHashable_EnvModeFromString(c string) TaskHashable_EnvMode {
	switch c {
	case "infer":
		return TaskHashable_EnvMode_infer
	case "loose":
		return TaskHashable_EnvMode_loose
	case "strict":
		return TaskHashable_EnvMode_strict

	default:
		return 0
	}
}

type TaskHashable_EnvMode_List = capnp.EnumList[TaskHashable_EnvMode]

func NewTaskHashable_EnvMode_List(s *capnp.Segment, sz int32) (TaskHashable_EnvMode_List, error) {
	return capnp.NewEnumList[TaskHashable_EnvMode](s, sz)
}

type TaskOutputs capnp.Struct

// TaskOutputs_TypeID is the unique identifier for the type TaskOutputs.
const TaskOutputs_TypeID = 0xd58300fce8aba267

func NewTaskOutputs(s *capnp.Segment) (TaskOutputs, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return TaskOutputs(st), err
}

func NewRootTaskOutputs(s *capnp.Segment) (TaskOutputs, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return TaskOutputs(st), err
}

func ReadRootTaskOutputs(msg *capnp.Message) (TaskOutputs, error) {
	root, err := msg.Root()
	return TaskOutputs(root.Struct()), err
}

func (s TaskOutputs) String() string {
	str, _ := text.Marshal(0xd58300fce8aba267, capnp.Struct(s))
	return str
}

func (s TaskOutputs) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (TaskOutputs) DecodeFromPtr(p capnp.Ptr) TaskOutputs {
	return TaskOutputs(capnp.Struct{}.DecodeFromPtr(p))
}

func (s TaskOutputs) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s TaskOutputs) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s TaskOutputs) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s TaskOutputs) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s TaskOutputs) Inclusions() (capnp.TextList, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return capnp.TextList(p.List()), err
}

func (s TaskOutputs) HasInclusions() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s TaskOutputs) SetInclusions(v capnp.TextList) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewInclusions sets the inclusions field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s TaskOutputs) NewInclusions(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}
func (s TaskOutputs) Exclusions() (capnp.TextList, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return capnp.TextList(p.List()), err
}

func (s TaskOutputs) HasExclusions() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s TaskOutputs) SetExclusions(v capnp.TextList) error {
	return capnp.Struct(s).SetPtr(1, v.ToPtr())
}

// NewExclusions sets the exclusions field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s TaskOutputs) NewExclusions(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = capnp.Struct(s).SetPtr(1, l.ToPtr())
	return l, err
}

// TaskOutputs_List is a list of TaskOutputs.
type TaskOutputs_List = capnp.StructList[TaskOutputs]

// NewTaskOutputs creates a new list of TaskOutputs.
func NewTaskOutputs_List(s *capnp.Segment, sz int32) (TaskOutputs_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[TaskOutputs](l), err
}

// TaskOutputs_Future is a wrapper for a TaskOutputs promised by a client call.
type TaskOutputs_Future struct{ *capnp.Future }

func (f TaskOutputs_Future) Struct() (TaskOutputs, error) {
	p, err := f.Future.Ptr()
	return TaskOutputs(p.Struct()), err
}

type GlobalHashable capnp.Struct

// GlobalHashable_TypeID is the unique identifier for the type GlobalHashable.
const GlobalHashable_TypeID = 0xea0b3688577e30b4

func NewGlobalHashable(s *capnp.Segment) (GlobalHashable, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 7})
	return GlobalHashable(st), err
}

func NewRootGlobalHashable(s *capnp.Segment) (GlobalHashable, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 7})
	return GlobalHashable(st), err
}

func ReadRootGlobalHashable(msg *capnp.Message) (GlobalHashable, error) {
	root, err := msg.Root()
	return GlobalHashable(root.Struct()), err
}

func (s GlobalHashable) String() string {
	str, _ := text.Marshal(0xea0b3688577e30b4, capnp.Struct(s))
	return str
}

func (s GlobalHashable) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (GlobalHashable) DecodeFromPtr(p capnp.Ptr) GlobalHashable {
	return GlobalHashable(capnp.Struct{}.DecodeFromPtr(p))
}

func (s GlobalHashable) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s GlobalHashable) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s GlobalHashable) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s GlobalHashable) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s GlobalHashable) GlobalCacheKey() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s GlobalHashable) HasGlobalCacheKey() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s GlobalHashable) GlobalCacheKeyBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s GlobalHashable) SetGlobalCacheKey(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s GlobalHashable) GlobalFileHashMap() (GlobalHashable_Entry_List, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return GlobalHashable_Entry_List(p.List()), err
}

func (s GlobalHashable) HasGlobalFileHashMap() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s GlobalHashable) SetGlobalFileHashMap(v GlobalHashable_Entry_List) error {
	return capnp.Struct(s).SetPtr(1, v.ToPtr())
}

// NewGlobalFileHashMap sets the globalFileHashMap field to a newly
// allocated GlobalHashable_Entry_List, preferring placement in s's segment.
func (s GlobalHashable) NewGlobalFileHashMap(n int32) (GlobalHashable_Entry_List, error) {
	l, err := NewGlobalHashable_Entry_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return GlobalHashable_Entry_List{}, err
	}
	err = capnp.Struct(s).SetPtr(1, l.ToPtr())
	return l, err
}
func (s GlobalHashable) RootExternalDepsHash() (string, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return p.Text(), err
}

func (s GlobalHashable) HasRootExternalDepsHash() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s GlobalHashable) RootExternalDepsHashBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return p.TextBytes(), err
}

func (s GlobalHashable) SetRootExternalDepsHash(v string) error {
	return capnp.Struct(s).SetText(2, v)
}

func (s GlobalHashable) Env() (capnp.TextList, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return capnp.TextList(p.List()), err
}

func (s GlobalHashable) HasEnv() bool {
	return capnp.Struct(s).HasPtr(3)
}

func (s GlobalHashable) SetEnv(v capnp.TextList) error {
	return capnp.Struct(s).SetPtr(3, v.ToPtr())
}

// NewEnv sets the env field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s GlobalHashable) NewEnv(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = capnp.Struct(s).SetPtr(3, l.ToPtr())
	return l, err
}
func (s GlobalHashable) ResolvedEnvVars() (capnp.TextList, error) {
	p, err := capnp.Struct(s).Ptr(4)
	return capnp.TextList(p.List()), err
}

func (s GlobalHashable) HasResolvedEnvVars() bool {
	return capnp.Struct(s).HasPtr(4)
}

func (s GlobalHashable) SetResolvedEnvVars(v capnp.TextList) error {
	return capnp.Struct(s).SetPtr(4, v.ToPtr())
}

// NewResolvedEnvVars sets the resolvedEnvVars field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s GlobalHashable) NewResolvedEnvVars(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = capnp.Struct(s).SetPtr(4, l.ToPtr())
	return l, err
}
func (s GlobalHashable) PassThroughEnv() (capnp.TextList, error) {
	p, err := capnp.Struct(s).Ptr(5)
	return capnp.TextList(p.List()), err
}

func (s GlobalHashable) HasPassThroughEnv() bool {
	return capnp.Struct(s).HasPtr(5)
}

func (s GlobalHashable) SetPassThroughEnv(v capnp.TextList) error {
	return capnp.Struct(s).SetPtr(5, v.ToPtr())
}

// NewPassThroughEnv sets the passThroughEnv field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s GlobalHashable) NewPassThroughEnv(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = capnp.Struct(s).SetPtr(5, l.ToPtr())
	return l, err
}
func (s GlobalHashable) EnvMode() GlobalHashable_EnvMode {
	return GlobalHashable_EnvMode(capnp.Struct(s).Uint16(0))
}

func (s GlobalHashable) SetEnvMode(v GlobalHashable_EnvMode) {
	capnp.Struct(s).SetUint16(0, uint16(v))
}

func (s GlobalHashable) FrameworkInference() bool {
	return capnp.Struct(s).Bit(16)
}

func (s GlobalHashable) SetFrameworkInference(v bool) {
	capnp.Struct(s).SetBit(16, v)
}

func (s GlobalHashable) DotEnv() (capnp.TextList, error) {
	p, err := capnp.Struct(s).Ptr(6)
	return capnp.TextList(p.List()), err
}

func (s GlobalHashable) HasDotEnv() bool {
	return capnp.Struct(s).HasPtr(6)
}

func (s GlobalHashable) SetDotEnv(v capnp.TextList) error {
	return capnp.Struct(s).SetPtr(6, v.ToPtr())
}

// NewDotEnv sets the dotEnv field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s GlobalHashable) NewDotEnv(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = capnp.Struct(s).SetPtr(6, l.ToPtr())
	return l, err
}

// GlobalHashable_List is a list of GlobalHashable.
type GlobalHashable_List = capnp.StructList[GlobalHashable]

// NewGlobalHashable creates a new list of GlobalHashable.
func NewGlobalHashable_List(s *capnp.Segment, sz int32) (GlobalHashable_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 7}, sz)
	return capnp.StructList[GlobalHashable](l), err
}

// GlobalHashable_Future is a wrapper for a GlobalHashable promised by a client call.
type GlobalHashable_Future struct{ *capnp.Future }

func (f GlobalHashable_Future) Struct() (GlobalHashable, error) {
	p, err := f.Future.Ptr()
	return GlobalHashable(p.Struct()), err
}

type GlobalHashable_EnvMode uint16

// GlobalHashable_EnvMode_TypeID is the unique identifier for the type GlobalHashable_EnvMode.
const GlobalHashable_EnvMode_TypeID = 0xab4200df8263c5d4

// Values of GlobalHashable_EnvMode.
const (
	GlobalHashable_EnvMode_infer  GlobalHashable_EnvMode = 0
	GlobalHashable_EnvMode_loose  GlobalHashable_EnvMode = 1
	GlobalHashable_EnvMode_strict GlobalHashable_EnvMode = 2
)

// String returns the enum's constant name.
func (c GlobalHashable_EnvMode) String() string {
	switch c {
	case GlobalHashable_EnvMode_infer:
		return "infer"
	case GlobalHashable_EnvMode_loose:
		return "loose"
	case GlobalHashable_EnvMode_strict:
		return "strict"

	default:
		return ""
	}
}

// GlobalHashable_EnvModeFromString returns the enum value with a name,
// or the zero value if there's no such value.
func GlobalHashable_EnvModeFromString(c string) GlobalHashable_EnvMode {
	switch c {
	case "infer":
		return GlobalHashable_EnvMode_infer
	case "loose":
		return GlobalHashable_EnvMode_loose
	case "strict":
		return GlobalHashable_EnvMode_strict

	default:
		return 0
	}
}

type GlobalHashable_EnvMode_List = capnp.EnumList[GlobalHashable_EnvMode]

func NewGlobalHashable_EnvMode_List(s *capnp.Segment, sz int32) (GlobalHashable_EnvMode_List, error) {
	return capnp.NewEnumList[GlobalHashable_EnvMode](s, sz)
}

type GlobalHashable_Entry capnp.Struct

// GlobalHashable_Entry_TypeID is the unique identifier for the type GlobalHashable_Entry.
const GlobalHashable_Entry_TypeID = 0xdd6c3d394436cf49

func NewGlobalHashable_Entry(s *capnp.Segment) (GlobalHashable_Entry, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return GlobalHashable_Entry(st), err
}

func NewRootGlobalHashable_Entry(s *capnp.Segment) (GlobalHashable_Entry, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return GlobalHashable_Entry(st), err
}

func ReadRootGlobalHashable_Entry(msg *capnp.Message) (GlobalHashable_Entry, error) {
	root, err := msg.Root()
	return GlobalHashable_Entry(root.Struct()), err
}

func (s GlobalHashable_Entry) String() string {
	str, _ := text.Marshal(0xdd6c3d394436cf49, capnp.Struct(s))
	return str
}

func (s GlobalHashable_Entry) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (GlobalHashable_Entry) DecodeFromPtr(p capnp.Ptr) GlobalHashable_Entry {
	return GlobalHashable_Entry(capnp.Struct{}.DecodeFromPtr(p))
}

func (s GlobalHashable_Entry) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s GlobalHashable_Entry) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s GlobalHashable_Entry) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s GlobalHashable_Entry) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s GlobalHashable_Entry) Key() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s GlobalHashable_Entry) HasKey() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s GlobalHashable_Entry) KeyBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s GlobalHashable_Entry) SetKey(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s GlobalHashable_Entry) Value() (string, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.Text(), err
}

func (s GlobalHashable_Entry) HasValue() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s GlobalHashable_Entry) ValueBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.TextBytes(), err
}

func (s GlobalHashable_Entry) SetValue(v string) error {
	return capnp.Struct(s).SetText(1, v)
}

// GlobalHashable_Entry_List is a list of GlobalHashable_Entry.
type GlobalHashable_Entry_List = capnp.StructList[GlobalHashable_Entry]

// NewGlobalHashable_Entry creates a new list of GlobalHashable_Entry.
func NewGlobalHashable_Entry_List(s *capnp.Segment, sz int32) (GlobalHashable_Entry_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[GlobalHashable_Entry](l), err
}

// GlobalHashable_Entry_Future is a wrapper for a GlobalHashable_Entry promised by a client call.
type GlobalHashable_Entry_Future struct{ *capnp.Future }

func (f GlobalHashable_Entry_Future) Struct() (GlobalHashable_Entry, error) {
	p, err := f.Future.Ptr()
	return GlobalHashable_Entry(p.Struct()), err
}

const schema_e1dde60149aeb063 = "x\xda\xa4\x94Mh\x1ce\x18\xc7\xff\xffw\xf6+\xc9" +
	"\xd6\xcd2\xe3g-\x91R\xb0\x15Z\xd2\xa6\x14\x0cH" +
	"\xda\x98\xd4\x04\xad\xe98E\xa1\xb4\x87\xc9\xee\x9b\xec\x9a" +
	"qg\x9d\x99\xcdGA\xa3\xd5C\x0czPz\x10\xad" +
	"`\xa5\x82X\x14\x05\x0f^\x84*x\x11D\x0b\xf5\"" +
	"\x84\x10\xb0\xd2j\x05/\x95\x1e\x0a#\xef\xec\xce\xee$" +
	"\xa1=\xe8iw~\xef\xf3>\xef3\xf3\xfc\x9e\xb7\x7f" +
	"Y\x1cL\xed\xdd2\xa7A\x98;\xd3\x99\xf0\x9e\xf7\xff" +
	"\xd9\xb5m\xf9\xe2[(\xde/\xc2\x85\xdfn<\xfd\xe7" +
	"\xd9\xbf\xd7\x00\x0e\x9cc7\xf5/\x99\x05\xf4\xcf8\x01" +
	"\xae^\xfe\xbetzu\xf8Bq\xab\x08\xbf\xea\x7f\xf9" +
	"\xb9\xa5\x03=\x7f\xa8\xb8o\xf9\x00\xf5KQ\xdc\x8fQ" +
	"\xdc\xf4G\x17\xae\xdez\xed\x97b\x9ea\xe9\x8b\xcf\xc7" +
	"\xf9\xfb\xca\x1a\xd2B\xad\xaf\xf1;\xfdZ\x14y\x85s" +
	"`8\xfe\xd3\x81\x91G\x1fsVP\xdc\xcaN\xce(" +
	"v\xa0*\xba\xa9/D\xdb\x1aB\x05\xb7k3\xf3L" +
	"f\xce\xab\x90K\xe2\x07}E\xdc\x0b\x0c\\\x11\xab\x02" +
	"\x89l\x1b\xa2\xb3*\xfad\xe6W\xbd\x9ay\x18\x18x" +
	")\x13\x12\xbb\xc3\xba\xe7\x06\xee\x9e\x92\xad\xd5k\xf5\xc1" +
	"c\xb6?3f\xfb\x15{\xd2\x91{Fk\xb3G\xdc" +
	"\xb2\x04\x8e\x92f\x9e\x02(n\xdb\x07\x90\xc5\xbb\xd5\x8f" +
	"(n\x19\x04\xfa\xaa\xb5)\xe9\xf59\xae\xeb\xcb!?" +
	"\xf0\xaa\xa5`}\xca'\x1cw\xd2v\xd6'\xd5\xca\xf2" +
	"\xbf\xe6\x14q\x99\x13\x8d\xa0\xde\x08\xfc\xa8\xb8\x9c\x96\x02" +
	"R\x04\x8a\xbb\x8e\x03\xe6N\x8d\xe6\x88`\x914\xa8\xe0" +
	"!\x05\x0fj4O\x08\x86\xd5Z\xc9i\xf8U\x17Z" +
	"\xcd\xe7]\xe0Q\x8d\xccC\xa8\xbf\xa1\x9c\xbf\xfd\xda\x9d" +
	"_*\xf0\x16\xb0\xb1\x94\xed\x80\xb9C\xa3\xd9\x9f(e" +
	"\xf7\xbeV}\xfb\x05\xb33r!J\x9f\x07\xfbfm" +
	"\xa7!\xe3\xa7\xcdo\x1b\x1f\x05\x98)2a.\x87\x17" +
	"[}2\xf7\xc7G\xeb'y\x1c\xb0NP\xa3Ua" +
	"\xe7t]\xf2S\xc0\xaa(\xfe\xba\xe2B\x18\xaa\x05\xfa" +
	"\xabQ\xfc+\x8a\xbf\xa9\xb8\xa6\x19\xd4\x00\xfd\x0dN\x02" +
	"\xd6\x92\xe2g\x14O\xa5\x0c\xa6\x00\xfdm.\x03\xd6\x19" +
	"\xc5?T<\x9d6\x98\x06\xf4\x0f\xf8\x08`\xbd\xab\xf8" +
	"y\xc53\x19\x83\x19@?\xc7a\xc0:\xab\xf8'\x8a" +
	"g\xb3F4\x0a\x1f\xf3y\xc0:\xaf\xf8E\xc5s9" +
	"\x839@\xff\x86\xdb\x01\xebk\xc5/+\xde\xd5e\xb0" +
	"K\xa9\xce\xd3\x80\xf5\xb3\xe2\xd7\x15\xef\xee6\xd8\x0d\xe8" +
	"\xd7\xa2:\xaf*\x9e\x12\x82\xec1\xd8\x03\xe8\x14\xea\xd8" +
	"[\x0a\xe7\x84`1\xdfc0\x0f\xe8i1\x08<#" +
	"4Z\x0f\x0a\xc1p\xba\xd5Lh~\xa5\xdd\x81\xc0\xf6" +
	"gFd]\xb2V\x96\xb5\xd2\xc2\x98]\xf0+r\xb3" +
	"\x14vi\xc6\x9e\x96#\xd0\xaa^{k\xc5\xf6+\x13" +
	"S\x87\xab\xc8:\xd2oS9\x1fH\xaff;\x1c\x91" +
	"u_\xb5\x13\x88\xd7\x0a\xea\xb0\xf8a\xd1m\x8a\xcd\xde" +
	"\xf86\x01\xd9\x1b\x9d\xe5\xfb\xc7*^\x03\x85C\xde\xf4" +
	"\xc6J\xb2\xb26\xbb\xb18O\xfa\xae3+\xcb\x1c\xad" +
	"\xcd>k{>6W\xdf\xca\x98\x1d\xdd\xb4{Q6" +
	"\xadb\xa1#\x1b\xc8\x028Tv\x83\xcd\xf1\xeb\x95M" +
	"\xce\x87\xe6H3\xc7\xce\x1d\xda5\x9c\xb8\xfc\xd2\xfbb" +
	"}\xfb\xa2!2w\xb4\xe7\xe7\xafS\x80y]\xa3y" +
	"31?7\xde\x01\xcc\x9b\x1a-#\xe9o1\xf2\xda" +
	"P\x8d~(\xe9\xef\xb6\xc8\xa3\xfb\x14\xdf\x9f\xf4wo" +
	"\xe4Q\xbf\xe2O%\xfd\x1d\xe7)\xc0\x1aS\xbcLA" +
	"\xb6\xf4\xb5#};\xe3\x94\xedm\xea+\xf9^<N" +
	"A\xa4o\xa6\xa9\xef\x8b\x1c\x04,G\xf1%\xb6\x05{" +
	"\xdc\xc6P\xa9\"\x9f\xec\x0c}k\xe1p\x95\x8eT\xdf" +
	"\xea\x88\xcdz\xfcY{;\x1f\x09l\xb6\xd3u\x83\xd1" +
	"\xf9@RY\xa4$*\xa8=q\xae\xff#\x80\x8b\xa1" +
	"\xc6t\xe5N\x0e\xc4\xcdk\x1a\x10Ny\xf6\x0br\xce" +
	"\xf583\xaenjY\xd3J\x92\x84 o\xa7\xc7\xbf" +
	"\x01\x00\x00\xff\xff\x9b\xa2\xb13"

func RegisterSchema(reg *schemas.Registry) {
	reg.Register(&schemas.Schema{
		String: schema_e1dde60149aeb063,
		Nodes: []uint64{
			0x8dc08a1d29f69b16,
			0xab4200df8263c5d4,
			0xd58300fce8aba267,
			0xdd6c3d394436cf49,
			0xe1f09ceb4ef5e479,
			0xea0b3688577e30b4,
		},
		Compressed: true,
	})
}
