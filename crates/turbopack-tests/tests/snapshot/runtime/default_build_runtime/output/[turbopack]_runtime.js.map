{
  "version": 3,
  "sections": [
    {"offset": {"line": 1, "column": 0}, "map": {"version":3,"sources":["/turbopack/[turbopack]/shared/runtime-utils.ts"],"sourcesContent":["/**\n * This file contains runtime types and functions that are shared between all\n * TurboPack ECMAScript runtimes.\n *\n * It will be prepended to the runtime code of each runtime.\n */\n\n/* eslint-disable @next/next/no-assign-module-variable */\n\n/// <reference path=\"./runtime-types.d.ts\" />\n\ninterface Exports {\n  __esModule?: boolean;\n\n  [key: string]: any;\n}\n\ntype EsmNamespaceObject = Record<string, any>;\n\nconst REEXPORTED_OBJECTS = Symbol(\"reexported objects\");\n\ninterface BaseModule {\n  exports: Exports | Promise<Exports> | AsyncModulePromise;\n  error: Error | undefined;\n  loaded: boolean;\n  id: ModuleId;\n  children: ModuleId[];\n  parents: ModuleId[];\n  namespaceObject?:\n    | EsmNamespaceObject\n    | Promise<EsmNamespaceObject>\n    | AsyncModulePromise<EsmNamespaceObject>;\n  [REEXPORTED_OBJECTS]?: any[];\n}\n\ninterface Module extends BaseModule {}\n\ntype RequireContextMap = Record<ModuleId, RequireContextEntry>;\n\ninterface RequireContextEntry {\n  id: () => ModuleId;\n}\n\ninterface RequireContext {\n  (moduleId: ModuleId): Exports | EsmNamespaceObject;\n\n  keys(): ModuleId[];\n\n  resolve(moduleId: ModuleId): ModuleId;\n}\n\ntype GetOrInstantiateModuleFromParent = (\n  moduleId: ModuleId,\n  parentModule: Module\n) => Module;\n\ntype CommonJsRequireContext = (\n  entry: RequireContextEntry,\n  parentModule: Module\n) => Exports;\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nconst toStringTag = typeof Symbol !== \"undefined\" && Symbol.toStringTag;\n\nfunction defineProp(\n  obj: any,\n  name: PropertyKey,\n  options: PropertyDescriptor & ThisType<any>\n) {\n  if (!hasOwnProperty.call(obj, name))\n    Object.defineProperty(obj, name, options);\n}\n\n/**\n * Adds the getters to the exports object.\n */\nfunction esm(exports: Exports, getters: Record<string, () => any>) {\n  defineProp(exports, \"__esModule\", { value: true });\n  if (toStringTag) defineProp(exports, toStringTag, { value: \"Module\" });\n  for (const key in getters) {\n    defineProp(exports, key, { get: getters[key], enumerable: true });\n  }\n}\n\n/**\n * Makes the module an ESM with exports\n */\nfunction esmExport(\n  module: Module,\n  exports: Exports,\n  getters: Record<string, () => any>\n) {\n  module.namespaceObject = module.exports;\n  esm(exports, getters);\n}\n\nfunction ensureDynamicExports(module: Module, exports: Exports) {\n  let reexportedObjects = module[REEXPORTED_OBJECTS];\n\n  if (!reexportedObjects) {\n    reexportedObjects = module[REEXPORTED_OBJECTS] = [];\n    module.exports = module.namespaceObject = new Proxy(exports, {\n      get(target, prop) {\n        if (\n          hasOwnProperty.call(target, prop) ||\n          prop === \"default\" ||\n          prop === \"__esModule\"\n        ) {\n          return Reflect.get(target, prop);\n        }\n        for (const obj of reexportedObjects!) {\n          const value = Reflect.get(obj, prop);\n          if (value !== undefined) return value;\n        }\n        return undefined;\n      },\n      ownKeys(target) {\n        const keys = Reflect.ownKeys(target);\n        for (const obj of reexportedObjects!) {\n          for (const key of Reflect.ownKeys(obj)) {\n            if (key !== \"default\" && !keys.includes(key)) keys.push(key);\n          }\n        }\n        return keys;\n      },\n    });\n  }\n}\n\n/**\n * Dynamically exports properties from an object\n */\nfunction dynamicExport(\n  module: Module,\n  exports: Exports,\n  object: Record<string, any>\n) {\n  ensureDynamicExports(module, exports);\n\n  module[REEXPORTED_OBJECTS]!.push(object);\n}\n\nfunction exportValue(module: Module, value: any) {\n  module.exports = value;\n}\n\nfunction exportNamespace(module: Module, namespace: any) {\n  module.exports = module.namespaceObject = namespace;\n}\n\nfunction createGetter(obj: Record<string | symbol, any>, key: string | symbol) {\n  return () => obj[key];\n}\n\n/**\n * @returns prototype of the object\n */\nconst getProto: (obj: any) => any = Object.getPrototypeOf\n  ? (obj) => Object.getPrototypeOf(obj)\n  : (obj) => obj.__proto__;\n\n/** Prototypes that are not expanded for exports */\nconst LEAF_PROTOTYPES = [null, getProto({}), getProto([]), getProto(getProto)];\n\n/**\n * @param raw\n * @param ns\n * @param allowExportDefault\n *   * `false`: will have the raw module as default export\n *   * `true`: will have the default property as default export\n */\nfunction interopEsm(\n  raw: Exports,\n  ns: EsmNamespaceObject,\n  allowExportDefault?: boolean\n) {\n  const getters: { [s: string]: () => any } = Object.create(null);\n  for (\n    let current = raw;\n    (typeof current === \"object\" || typeof current === \"function\") &&\n    !LEAF_PROTOTYPES.includes(current);\n    current = getProto(current)\n  ) {\n    for (const key of Object.getOwnPropertyNames(current)) {\n      getters[key] = createGetter(raw, key);\n    }\n  }\n\n  // this is not really correct\n  // we should set the `default` getter if the imported module is a `.cjs file`\n  if (!(allowExportDefault && \"default\" in getters)) {\n    getters[\"default\"] = () => raw;\n  }\n\n  esm(ns, getters);\n  return ns;\n}\n\nfunction esmImport(\n  sourceModule: Module,\n  id: ModuleId\n): Exclude<Module[\"namespaceObject\"], undefined> {\n  const module = getOrInstantiateModuleFromParent(id, sourceModule);\n  if (module.error) throw module.error;\n\n  // any ES module has to have `module.namespaceObject` defined.\n  if (module.namespaceObject) return module.namespaceObject;\n\n  // only ESM can be an async module, so we don't need to worry about exports being a promise here.\n  const raw = module.exports;\n  return (module.namespaceObject = interopEsm(\n    raw,\n    {},\n    (raw as any).__esModule\n  ));\n}\n\nfunction commonJsRequire(sourceModule: Module, id: ModuleId): Exports {\n  const module = getOrInstantiateModuleFromParent(id, sourceModule);\n  if (module.error) throw module.error;\n  return module.exports;\n}\n\ntype RequireContextFactory = (map: RequireContextMap) => RequireContext;\n\nfunction requireContext(\n  sourceModule: Module,\n  map: RequireContextMap\n): RequireContext {\n  function requireContext(id: ModuleId): Exports {\n    const entry = map[id];\n\n    if (!entry) {\n      throw new Error(\n        `module ${id} is required from a require.context, but is not in the context`\n      );\n    }\n\n    return commonJsRequireContext(entry, sourceModule);\n  }\n\n  requireContext.keys = (): ModuleId[] => {\n    return Object.keys(map);\n  };\n\n  requireContext.resolve = (id: ModuleId): ModuleId => {\n    const entry = map[id];\n\n    if (!entry) {\n      throw new Error(\n        `module ${id} is resolved from a require.context, but is not in the context`\n      );\n    }\n\n    return entry.id();\n  };\n\n  return requireContext;\n}\n\n/**\n * Returns the path of a chunk defined by its data.\n */\nfunction getChunkPath(chunkData: ChunkData): ChunkPath {\n  return typeof chunkData === \"string\" ? chunkData : chunkData.path;\n}\n\nfunction isPromise<T = any>(maybePromise: any): maybePromise is Promise<T> {\n  return (\n    maybePromise != null &&\n    typeof maybePromise === \"object\" &&\n    \"then\" in maybePromise &&\n    typeof maybePromise.then === \"function\"\n  );\n}\n\nfunction isAsyncModuleExt<T extends {}>(obj: T): obj is AsyncModuleExt & T {\n  return turbopackQueues in obj;\n}\n\nfunction createPromise<T>() {\n  let resolve: (value: T | PromiseLike<T>) => void;\n  let reject: (reason?: any) => void;\n\n  const promise = new Promise<T>((res, rej) => {\n    reject = rej;\n    resolve = res;\n  });\n\n  return {\n    promise,\n    resolve: resolve!,\n    reject: reject!,\n  };\n}\n\n// everything below is adapted from webpack\n// https://github.com/webpack/webpack/blob/6be4065ade1e252c1d8dcba4af0f43e32af1bdc1/lib/runtime/AsyncModuleRuntimeModule.js#L13\n\nconst turbopackQueues = Symbol(\"turbopack queues\");\nconst turbopackExports = Symbol(\"turbopack exports\");\nconst turbopackError = Symbol(\"turbopack error\");\n\ntype AsyncQueueFn = (() => void) & { queueCount: number };\ntype AsyncQueue = AsyncQueueFn[] & { resolved: boolean };\n\nfunction resolveQueue(queue?: AsyncQueue) {\n  if (queue && !queue.resolved) {\n    queue.resolved = true;\n    queue.forEach((fn) => fn.queueCount--);\n    queue.forEach((fn) => (fn.queueCount-- ? fn.queueCount++ : fn()));\n  }\n}\n\ntype Dep = Exports | AsyncModulePromise | Promise<Exports>;\n\ntype AsyncModuleExt = {\n  [turbopackQueues]: (fn: (queue: AsyncQueue) => void) => void;\n  [turbopackExports]: Exports;\n  [turbopackError]?: any;\n};\n\ntype AsyncModulePromise<T = Exports> = Promise<T> & AsyncModuleExt;\n\nfunction wrapDeps(deps: Dep[]): AsyncModuleExt[] {\n  return deps.map((dep) => {\n    if (dep !== null && typeof dep === \"object\") {\n      if (isAsyncModuleExt(dep)) return dep;\n      if (isPromise(dep)) {\n        const queue: AsyncQueue = Object.assign([], { resolved: false });\n\n        const obj: AsyncModuleExt = {\n          [turbopackExports]: {},\n          [turbopackQueues]: (fn: (queue: AsyncQueue) => void) => fn(queue),\n        };\n\n        dep.then(\n          (res) => {\n            obj[turbopackExports] = res;\n            resolveQueue(queue);\n          },\n          (err) => {\n            obj[turbopackError] = err;\n            resolveQueue(queue);\n          }\n        );\n\n        return obj;\n      }\n    }\n\n    const ret: AsyncModuleExt = {\n      [turbopackExports]: dep,\n      [turbopackQueues]: () => {},\n    };\n\n    return ret;\n  });\n}\n\nfunction asyncModule(\n  module: Module,\n  body: (\n    handleAsyncDependencies: (\n      deps: Dep[]\n    ) => Exports[] | Promise<() => Exports[]>,\n    asyncResult: (err?: any) => void\n  ) => void,\n  hasAwait: boolean\n) {\n  const queue: AsyncQueue | undefined = hasAwait\n    ? Object.assign([], { resolved: true })\n    : undefined;\n\n  const depQueues: Set<AsyncQueue> = new Set();\n\n  ensureDynamicExports(module, module.exports);\n  const exports = module.exports;\n\n  const { resolve, reject, promise: rawPromise } = createPromise<Exports>();\n\n  const promise: AsyncModulePromise = Object.assign(rawPromise, {\n    [turbopackExports]: exports,\n    [turbopackQueues]: (fn) => {\n      queue && fn(queue);\n      depQueues.forEach(fn);\n      promise[\"catch\"](() => {});\n    },\n  } satisfies AsyncModuleExt);\n\n  module.exports = module.namespaceObject = promise;\n\n  function handleAsyncDependencies(deps: Dep[]) {\n    const currentDeps = wrapDeps(deps);\n\n    const getResult = () =>\n      currentDeps.map((d) => {\n        if (d[turbopackError]) throw d[turbopackError];\n        return d[turbopackExports];\n      });\n\n    const { promise, resolve } = createPromise<() => Exports[]>();\n\n    const fn: AsyncQueueFn = Object.assign(() => resolve(getResult), {\n      queueCount: 0,\n    });\n\n    function fnQueue(q: AsyncQueue) {\n      if (q !== queue && !depQueues.has(q)) {\n        depQueues.add(q);\n        if (q && !q.resolved) {\n          fn.queueCount++;\n          q.push(fn);\n        }\n      }\n    }\n\n    currentDeps.map((dep) => dep[turbopackQueues](fnQueue));\n\n    return fn.queueCount ? promise : getResult();\n  }\n\n  function asyncResult(err?: any) {\n    if (err) {\n      reject((promise[turbopackError] = err));\n    } else {\n      resolve(exports);\n    }\n\n    resolveQueue(queue);\n  }\n\n  body(handleAsyncDependencies, asyncResult);\n\n  if (queue) {\n    queue.resolved = false;\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 235, "column": 0}, "map": {"version":3,"sources":["/turbopack/[turbopack]/shared-node/node-utils.ts"],"sourcesContent":["/// <reference path=\"../shared/runtime-utils.ts\" />\n\ninterface RequireContextEntry {\n  external: boolean;\n}\n\nfunction commonJsRequireContext(\n  entry: RequireContextEntry,\n  sourceModule: Module\n): Exports {\n  return entry.external\n    ? externalRequire(entry.id(), false)\n    : commonJsRequire(sourceModule, entry.id());\n}\n\nfunction externalImport(id: ModuleId) {\n  return import(id);\n}\n\nfunction externalRequire(\n  id: ModuleId,\n  esm: boolean = false\n): Exports | EsmNamespaceObject {\n  let raw;\n  try {\n    raw = require(id);\n  } catch (err) {\n    // TODO(alexkirsz) This can happen when a client-side module tries to load\n    // an external module we don't provide a shim for (e.g. querystring, url).\n    // For now, we fail semi-silently, but in the future this should be a\n    // compilation error.\n    throw new Error(`Failed to load external module ${id}: ${err}`);\n  }\n\n  if (!esm || raw.__esModule) {\n    return raw;\n  }\n\n  return interopEsm(raw, {}, true);\n}\nexternalRequire.resolve = (\n  id: string,\n  options?: {\n    paths?: string[];\n  }\n) => {\n  return require.resolve(id, options);\n};\n\nasync function loadWebAssemblyFromPath(\n  path: string,\n  importsObj: WebAssembly.Imports\n): Promise<Exports> {\n  const { readFile } = require(\"fs/promises\") as typeof import(\"fs/promises\");\n\n  const buffer = await readFile(path);\n  const { instance } = await WebAssembly.instantiate(buffer, importsObj);\n\n  return instance.exports;\n}\n"],"names":[],"mappings":";AAMA,SAAS,uBACP,KAA0B,EAC1B,YAAoB;IAEpB,OAAO,MAAM,QAAQ,GACjB,gBAAgB,MAAM,EAAE,IAAI,SAC5B,gBAAgB,cAAc,MAAM,EAAE;AAC5C;AAEA,SAAS,eAAe,EAAY;IAClC,OAAO,MAAM,CAAC;AAChB;AAEA,SAAS,gBACP,EAAY,EACZ,MAAe,KAAK;IAEpB,IAAI;IACJ,IAAI;QACF,MAAM,QAAQ;IAChB,EAAE,OAAO,KAAK;QAKZ,MAAM,IAAI,MAAM,CAAC,+BAA+B,EAAE,GAAG,EAAE,EAAE,IAAI,CAAC;IAChE;IAEA,IAAI,CAAC,OAAO,IAAI,UAAU,EAAE;QAC1B,OAAO;IACT;IAEA,OAAO,WAAW,KAAK,CAAC,GAAG;AAC7B;AACA,gBAAgB,OAAO,GAAG,CACxB,IACA;IAIA,OAAO,QAAQ,OAAO,CAAC,IAAI;AAC7B;AAEA,eAAe,wBACb,IAAY,EACZ,UAA+B;IAE/B,MAAM,EAAE,QAAQ,EAAE,GAAG,QAAQ;IAE7B,MAAM,SAAS,MAAM,SAAS;IAC9B,MAAM,EAAE,QAAQ,EAAE,GAAG,MAAM,YAAY,WAAW,CAAC,QAAQ;IAE3D,OAAO,SAAS,OAAO;AACzB"}},
    {"offset": {"line": 263, "column": 0}, "map": {"version":3,"sources":["/turbopack/[turbopack]/build/runtime.ts"],"sourcesContent":["/// <reference path=\"../shared/runtime-utils.ts\" />\n/// <reference path=\"../shared-node/node-utils.ts\" />\n\ndeclare var RUNTIME_PUBLIC_PATH: string;\n\nenum SourceType {\n  /**\n   * The module was instantiated because it was included in an evaluated chunk's\n   * runtime.\n   */\n  Runtime = 0,\n  /**\n   * The module was instantiated because a parent module imported it.\n   */\n  Parent = 1,\n}\n\ntype SourceInfo =\n  | {\n      type: SourceType.Runtime;\n      chunkPath: ChunkPath;\n    }\n  | {\n      type: SourceType.Parent;\n      parentId: ModuleId;\n    };\n\ntype ExternalRequire = (id: ModuleId) => Exports | EsmNamespaceObject;\ntype ExternalImport = (id: ModuleId) => Promise<Exports | EsmNamespaceObject>;\n\ninterface TurbopackNodeBuildContext extends TurbopackBaseContext {\n  x: ExternalRequire;\n  y: ExternalImport;\n}\n\ntype ModuleFactory = (\n  this: Module[\"exports\"],\n  context: TurbopackNodeBuildContext\n) => undefined;\n\nconst path = require(\"path\");\nconst relativePathToRuntimeRoot = path.relative(RUNTIME_PUBLIC_PATH, \".\");\nconst RUNTIME_ROOT = path.resolve(__filename, relativePathToRuntimeRoot);\n\nconst moduleFactories: ModuleFactories = Object.create(null);\nconst moduleCache: ModuleCache = Object.create(null);\n\nfunction loadChunk(chunkPath: ChunkPath) {\n  if (!chunkPath.endsWith(\".js\")) {\n    // We only support loading JS chunks in Node.js.\n    // This branch can be hit when trying to load a CSS chunk.\n    return;\n  }\n\n  const resolved = path.resolve(RUNTIME_ROOT, chunkPath);\n  const chunkModules: ModuleFactories = require(resolved);\n\n  for (const [moduleId, moduleFactory] of Object.entries(chunkModules)) {\n    if (!moduleFactories[moduleId]) {\n      moduleFactories[moduleId] = moduleFactory;\n    }\n  }\n}\n\nfunction loadChunkAsync(source: SourceInfo, chunkPath: string): Promise<void> {\n  return new Promise<void>((resolve, reject) => {\n    try {\n      loadChunk(chunkPath);\n    } catch (err) {\n      reject(err);\n      return;\n    }\n    resolve();\n  });\n}\n\nfunction loadWebAssembly(chunkPath: ChunkPath, imports: WebAssembly.Imports) {\n  const resolved = path.resolve(RUNTIME_ROOT, chunkPath);\n\n  return loadWebAssemblyFromPath(resolved, imports);\n}\n\nfunction instantiateModule(id: ModuleId, source: SourceInfo): Module {\n  const moduleFactory = moduleFactories[id];\n  if (typeof moduleFactory !== \"function\") {\n    // This can happen if modules incorrectly handle HMR disposes/updates,\n    // e.g. when they keep a `setTimeout` around which still executes old code\n    // and contains e.g. a `require(\"something\")` call.\n    let instantiationReason;\n    switch (source.type) {\n      case SourceType.Runtime:\n        instantiationReason = `as a runtime entry of chunk ${source.chunkPath}`;\n        break;\n      case SourceType.Parent:\n        instantiationReason = `because it was required from module ${source.parentId}`;\n        break;\n    }\n    throw new Error(\n      `Module ${id} was instantiated ${instantiationReason}, but the module factory is not available. It might have been deleted in an HMR update.`\n    );\n  }\n\n  let parents: ModuleId[];\n  switch (source.type) {\n    case SourceType.Runtime:\n      parents = [];\n      break;\n    case SourceType.Parent:\n      // No need to add this module as a child of the parent module here, this\n      // has already been taken care of in `getOrInstantiateModuleFromParent`.\n      parents = [source.parentId];\n      break;\n  }\n\n  const module: Module = {\n    exports: {},\n    error: undefined,\n    loaded: false,\n    id,\n    parents,\n    children: [],\n    namespaceObject: undefined,\n  };\n  moduleCache[id] = module;\n\n  // NOTE(alexkirsz) This can fail when the module encounters a runtime error.\n  try {\n    moduleFactory.call(module.exports, {\n      a: asyncModule.bind(null, module),\n      e: module.exports,\n      r: commonJsRequire.bind(null, module),\n      x: externalRequire,\n      y: externalImport,\n      f: requireContext.bind(null, module),\n      i: esmImport.bind(null, module),\n      s: esmExport.bind(null, module, module.exports),\n      j: dynamicExport.bind(null, module, module.exports),\n      v: exportValue.bind(null, module),\n      n: exportNamespace.bind(null, module),\n      m: module,\n      c: moduleCache,\n      l: loadChunkAsync.bind(null, { type: SourceType.Parent, parentId: id }),\n      w: loadWebAssembly,\n      g: globalThis,\n      __dirname: module.id.replace(/(^|\\/)[\\/]+$/, \"\"),\n    });\n  } catch (error) {\n    module.error = error as any;\n    throw error;\n  }\n\n  module.loaded = true;\n  if (module.namespaceObject && module.exports !== module.namespaceObject) {\n    // in case of a circular dependency: cjs1 -> esm2 -> cjs1\n    interopEsm(module.exports, module.namespaceObject);\n  }\n\n  return module;\n}\n\n/**\n * Retrieves a module from the cache, or instantiate it if it is not cached.\n */\nfunction getOrInstantiateModuleFromParent(\n  id: ModuleId,\n  sourceModule: Module\n): Module {\n  const module = moduleCache[id];\n\n  if (sourceModule.children.indexOf(id) === -1) {\n    sourceModule.children.push(id);\n  }\n\n  if (module) {\n    if (module.parents.indexOf(sourceModule.id) === -1) {\n      module.parents.push(sourceModule.id);\n    }\n\n    return module;\n  }\n\n  return instantiateModule(id, {\n    type: SourceType.Parent,\n    parentId: sourceModule.id,\n  });\n}\n\n/**\n * Instantiates a runtime module.\n */\nfunction instantiateRuntimeModule(\n  moduleId: ModuleId,\n  chunkPath: ChunkPath\n): Module {\n  return instantiateModule(moduleId, { type: SourceType.Runtime, chunkPath });\n}\n\n/**\n * Retrieves a module from the cache, or instantiate it as a runtime module if it is not cached.\n */\nfunction getOrInstantiateRuntimeModule(\n  moduleId: ModuleId,\n  chunkPath: ChunkPath\n): Module {\n  const module = moduleCache[moduleId];\n  if (module) {\n    if (module.error) {\n      throw module.error;\n    }\n    return module;\n  }\n\n  return instantiateRuntimeModule(moduleId, chunkPath);\n}\n\nmodule.exports = {\n  getOrInstantiateRuntimeModule,\n  loadChunk,\n};\n"],"names":[],"mappings":"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"}}]
}